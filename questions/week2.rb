module Week2
  @week2 = [
    { question: 'What is an API?', answer: 'API is an Application Programming Interface. It is a software intermediary that allows two applications to talk to each other' },
    { question: 'What are the three key components of a user story?', answer: 'We use user stories to succinctly define a feature that delivers business value to an end user. A good user story identifies: The specific role of the user we are trying to serve (As a...) What that role wants to do in the context of the application (I want to...) Why that role wants to work with that functionality (So that...)' },
    { question: 'What is Acceptance Testing? How is it different from Unit Testing?', answer: 'While unit testing is low level and often performed for the benefit of the development team, acceptance tests are written with the user in mind.' },
    { question: 'How does capybara help us to perform acceptance testing?', answer: 'Capybara is a ruby gem that works with RSpec and other ruby testing libraries. It provides us with methods like fill_in and click so that we can impersonate an end user. Tools like capybara-webkit and poltergeist can assist with testing JavaScript.' },
    { question: 'Explain what a Promise is in JS', answer: 'Promises provide an API that allows us to execute asynchronous code, and then handle the success or failure of that code. A promise is an object that may produce a single value sometime in the future: either a resolved value or a reason that it\'s not resolved (e.g., a network error occurred). A promise may be in one of 3 possible states: fulfilled, rejected, or pending. Routines handling a promise can attach callbacks to handle the fulfilled value or the reason for rejection.' },
    { question: 'Explain the difference between synchronous and asynchronous functions.', answer: 'Synchronous functions are blocking while asynchronous functions are not. In synchronous functions, statements complete before the next statement is run. Asynchronous functions usually accept a callback as a parameter and execution continues on the next line immediately after the asynchronous function is invoked. The callback is only invoked when the asynchronous operation is complete.' },
    { question: 'What are the key elements or components of an HTTP request?', answer: 'An HTTP has two main components: the header and the request body. In the case of a request that results from a form submission, the body may contain parameters that will inform the server with user supplied data. The header contains important information about the request.' },
    { question: 'Walk me through how an HTTP request is served.', answer: 'In an HTTP interaction, there is a client and a server. An HTTP request is initiated by the client. The client sends the server important information like the path being requested, the HTTP method, and the Content-Type being requested. If the server is found and it is available, it responds to the client in the form of an HTTP response. The response includes the body of the requested document, the status code that provides a hint to the client around how the server processed the request, and the Content-Type of the body.' },
    { question: 'Why is it better to direct web traffic over HTTPS as opposed to plain HTTP?', answer: 'HTTP traffic is transmitted over plain text. Anyone listening in on the network conversation can gain access to secure data like passwords and credit card numbers. HTTPS traffic is encrypted, so anyone listening in would need a very complex encryption key to decipher who is saying what.' },
    { question: 'In the context of HTTP, what is a query string and how is it used?', answer: 'Query strings are URI encoded strings that often appear at the end of a URL. They start after the ? in an HTTP request. We often use a query string to qualify a GET request with more information.' },
    { question: 'What does it mean when we say HTTP is stateless? What are the benefits and drawbacks of having a stateless protocol?', answer: 'A stateless protocol does not require the server to retain information or status about each user for the duration of multiple requests. This simplifies the contract between client and server, and in many cases minimizes the amount of data that needs to be transferred.' }
  ]

  def self.flashcards
    @week2
  end

end
